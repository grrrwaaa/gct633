<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Cellular systems and lattice models</title>
    
<link href="css/site.css" media="screen" rel="stylesheet" type="text/css" />
<link href="css/highlight.default.css" media="screen" rel="stylesheet" type="text/css" />
  
<script src="js/jquery.js"></script>
<script src="js/socket.io.js"></script>
<script src="js/main.js" type="text/javascript"></script>

<link rel="icon" type="image/x-icon" href="favicon.ico" />
</head>
<body>
<div id="wrapper">
	
	<div class="header">
		<h1>GCT 753</h1>
		<a href="index.html">Overview</a><br/>
		<a href="software.html">Software</a><br/>
		<a href="lua.html">Lua Tutorial</a><br/>
		<br>
		<a href="introduction.html">Themes</a><br/>
		<a href="artificial_life.html">Artificial Life</a><br/>
		<a href="generative_art.html">Generative Art</a><br/>
		<br>
		<a href="cellular.html">Cellular Systems</a><br/>
		
	</div>
	<div class="section"><h1>Cellular systems and lattice models</h1>
<p>Provides an interesting continuum between non-living (such as molecules in crystal and metalline structures) and living (such as cells of a multi-cellular organism). The main difference is that, although both begin with more or less &#39;the same program&#39;, in living material the individual behavior of each cell specializes according to early conditions. This is important for <em>developmental biology</em>. Of course, computational cellular systems are far, far simpler than biological cells; but still draw from this inpsiration. The CA model was propsed by Stanislaw Ulam and used by von Neumann to demonstrate machines that can reproduce themselves; a more concise example being proposed by <a href="http://www.youtube.com/watch?v=2iDc4C6vbcc">Christopher Langton</a> decades later, itself later <a href="http://www.youtube.com/watch?v=vbpoTZlNTiw&amp;NR=1&amp;feature=endscreen">improved upon using artificial evolutionary techniques</a>.</p>
<p><a href="http://www.interciencia.es/PDF/WikipediaBooks/CellAutomata.pdf">The wikibooks on CA</a>.</p>
<p>The essential components that define a cellular system:</p>
<ul>
<li><strong>Cellular space:</strong> A collection of cells arranged into a discrete lattice, such as a 2D grid. </li>
<li><strong>Cell states:</strong> The information representing the current condition of a cell. In <em>Game of Life</em> this is either 0 or 1, but in other systems the state could be represented by an n-tuple of values, or something more complex. The set of possible states could be defined as finite or unbounded.</li>
<li><strong>Initial conditions:</strong> What state the cells are in at the start of the simulation.</li>
<li><strong>Neighborhood:</strong> The set of adjacent/nearby cells that can directly influence a particular cell. In <em>Game of Life</em> these are the 8 side and corner neighbors (the <em>Moore</em> neighborhood). In other systems it could be expressed as a radius or range.</li>
<li><strong>State transition function:</strong> The rule that a cell follows to update its state, which depends on the current state and the state of the neighborhood.</li>
<li><strong>Time axis:</strong> The cells are generally updated in a discrete fashion, which may be synchronous (all cells update simultaneously) or asynchronous (cells update separately, e.g. in a probabilistic manner).</li>
<li><strong>Boundary conditions:</strong> What happens to cells at the edges. A periodic boundary &#39;wraps around&#39; to the opposite edge; a static boundary always has the same state, a copying or reflective boundary mirrors the neighbor state, etc.</li>
</ul>
<h2>Cellular automata</h2>
<p>The mathematical notion of <em>automaton</em> indicates a discrete-time system with finite set of possible states, a finite number of inputs, a finite number of outputs, and a transition rule which gives the state at the next step in terms of the state and inputs at the previous step.</p>
<p>A <em>CA</em> applies this notion to a cellular space. It has discrete time, finite neighborhood (inputs), finite state set (often represented as integers) and synchronous update. The transition rule (or CA rule) is usually deterministic, giving a cell state[t+1] as a function of the states[t] of itself and neighbours; and all cells use the same transition rule. </p>
<p>The space itself is usually 1D, 2D or 3D, but rarely greater. Wolfram performed most of his research using 1D CAs, such as the &#39;rule 30&#39; CA below, whose evolution bears similarities with some shell patterns. The most famous CA <em>Game of Life</em> is 2D, which is so popular that people have written <a href="http://www.youtube.com/watch?v=My8AsV7bA94">Turing machines</a> and <a href="http://www.youtube.com/watch?v=xP5-iIeKXE8">Game of Life</a> in terms of it. <a href="https://www.youtube.com/watch?v=wNypW-aSCmE">Over here a 3D cellular automaton is taking over Minecraft</a>, and <a href="http://www.youtube.com/watch?v=PBXO_6Jn1fs">here is a self-replicating computer in 3D</a>.</p>
<p><img src="img/ca_shells.jpg" alt="Evolution of a 1D CA: rule 30"></p>
<p>Wolfram divided CA into four classes, according to their long-term behavior:</p>
<ul>
<li><strong>Class 1</strong> - stable. Evolves to homogeneous state.</li>
<li><strong>Class 2</strong> - cyclic. Evolves to simple separated periodic structures. Local changes to the initial pattern tend to remain local</li>
<li><strong>Class 3</strong> - chaotic. Any stable structures that appear are quickly destroyed by the surrounding noise. Local changes to the initial pattern tend to spread indefinitely</li>
<li><strong>Class 4</strong> - complex. Local changes to the initial pattern may spread indefinitely. Wolfram has conjectured that many, if not all class 4 cellular automata are capable of universal computation.</li>
</ul>
<h3>Conway&#39;s Game of Life</h3>
<p>The <em>Game of Life</em> CA is an example of a <em>outer totalistic</em> CA: The spatial directions of cells do not matter, only the total value of all neighbors is used, along with the current value of teh cell itself. The transition rule for a cell can be stated concisely as follows:</p>
<ul>
<li>If the current state is 1 (&quot;alive&quot;):<ul>
<li>If the neighbor total is less than 2: New state is 0 (&quot;death by loneliness&quot;)</li>
<li>Else if the neighbor total is greater than 3: New state is 0 (&quot;death by overcrowding&quot;)</li>
<li>Else: State remains the same (&quot;alive&quot;)</li>
</ul>
</li>
<li>If the current state is 0 (&quot;dead&quot;):<ul>
<li>If the neigbor total is exactly 3: New state is 1 (&quot;reproduction&quot;)</li>
<li>Else: State remains the same (&quot;dead&quot;)</li>
</ul>
</li>
</ul>
<p>Or, in Lua:</p>
<pre><code class="lang-lua"><span class="keyword">if</span> state == <span class="number">1</span> <span class="keyword">then</span>
    <span class="comment">-- currently alive</span>
    <span class="keyword">if</span> neighbors &lt; <span class="number">2</span> <span class="keyword">then</span>
        <span class="comment">-- death by loneliness</span>
        state = <span class="number">0</span>
    <span class="keyword">elseif</span> neighbors &gt; <span class="number">3</span> <span class="keyword">then</span>
        <span class="comment">-- death by overcrowding</span>
        state = <span class="number">0</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>
    <span class="comment">-- currently dead</span>
    <span class="keyword">if</span> neighbors == <span class="number">3</span> <span class="keyword">then</span>
        <span class="comment">-- birth by reproduction</span>
        state = <span class="number">1</span>
    <span class="keyword">end</span>
<span class="keyword">end</span></code></pre>
<p>The Game of Life produces easily recognizable higher-level formations including stable objects, oscillatory objects, mobile objects and objects that produce or consume others, for example, which have been called &#39;ponds&#39;, &#39;gliders&#39;, &#39;eaters&#39;, &#39;glider guns&#39; and so on. In Wolfram&#39;s terms, it is <em>Class 4</em> CA.</p>
<p>Note that these rules mean that the Game of Life is not reversible: from a given state it is not possible to determine the previous state.</p>
<h3>Implementation</h3>
<p>If the cells are densely packed into a regular lattice structure, such as a 2D grid, they can efficiently be represented as <em>array</em> memory blocks. The state of a cell can be represented by a number, so an array of integers works well. A way to index this array memory to read or write a cell coordinate will be useful.</p>
<p>In theory the transition rule can be represented as a <em>look-up table</em>, however above a certain number of states and neighbors the size of this table would become astronomical (k states raised to the power of k neighbor states raised to the power of n neighbors; for a 3-state, 3-neighbor system this requires 7 billon rules!), so a procedural implementation is preferable. CAs may use bit-wise operators to implement the transition rules in a hardware-optimized way, but we will use regular <code>if</code> statements, like the above, for clarity. </p>
<p>One complication is that the states of the whole lattice must update synchronously. That means: when one cell changes, all cells should change. This is not easy to achieve in most computing systems today, which mostly follow instructions one at a time (with only limited parallelism). A naive implementation will thus update cells one at a time, and the neighborhood of a particular cell will contain both &#39;past&#39; and &#39;future&#39; states. One way to work around this is to maintain two copies of the lattice; one for the &#39;past&#39; states, and one for the &#39;future&#39; states. The transition rule always reads from the &#39;past&#39; lattice, and always writes to the &#39;future&#39; lattice. After all cells are updated, either the &#39;future&#39; is copied to the &#39;past&#39;, or the &#39;future&#39; and &#39;past&#39; lattices are swapped, since the future of yesterday is the past of tomorrow. </p>
<blockquote>
<p>This technique is called <em>double-buffering</em>, and is widely used in software systems where a parallel process interacts with a serial machine. It is used to render graphics to the screen, for example.</p>
</blockquote>
<h2>Variations</h2>
<h3>Non-homogenous CA</h3>
<p>The rule is not the same for all cells / for all time steps. Spatial non-homogeneity can be interesting to simulate different geographies (such as boundaries). Temporal non-homogeneity can be used to perform a sequence of different filters. </p>
<p>Or perhaps the neighborhood selection may change between updates (also see particle CA below).</p>
<p>These can be implemented by changing the function used in the transition rule, or by extending the state set to accommodate the differences. Changing the function is usually easier to implement and understand.</p>
<h3>Probabilistic/Stochastic CA</h3>
<p>In this case the transition rule is not deterministic, but includes some random factor. For example, a probability can be assigned to each successor state according to the prior states. </p>
<p>Take a look at the <a href="https://github.com/grrrwaaa/gct753/blob/master/ca_2D_forest_fire.lua">Forest Fire CA example</a>, and try changing the probabilities to see how it behaves.</p>
<p>Also try modifying Game of Life to include a very small probability of randomly changing state, for example.</p>
<h3>Particle CA, Lattice-Gas Automata and Block Rule CA</h3>
<p>The cell states represent the presence (or absence) of particles in a cell, and transition rules represent how particles move across cells. Generally the transition rule must preserve the quantity of particles. The elementary 1D traffic CA (rule 184) is a simple particle CA. </p>
<p>An implementation option is to use <em>block rules</em>, which consider small regions at a time, rather than individual cells; e.g. a 2x2 region of cells in a 2D CA (the <em>Margolus neighborhood</em>). To handle the boundaries between blocks, the regions are shifted between each application (<a href="http://en.wikipedia.org/wiki/Block_cellular_automaton">see wikipedia</a>). </p>
<p><img src="img/mnhood.gif" alt="Margolus neigborhood"></p>
<p>Note that a block rule CA does not need to be implemented with two buffers, since each block updates synchronously internally, and independently externally.</p>
<p>More example block CAs <a href="http://psoup.math.wisc.edu/mcell/rullex_marg.html">here</a> -- many of these are implemented <a href="https://github.com/grrrwaaa/gct753/blob/master/ca_2D_block_rules.lua">in the example script here</a>. </p>
<p>In 1969, German computer pioneer (and painter) Konrad Zuse published his book <a href="ftp://ftp.idsia.ch/pub/juergen/zuserechnenderraum.pdf">Calculating Space</a>, proposing that the physical laws of the universe are discrete by nature, and that the entire universe is the output of a deterministic computation on a single cellular automaton. This became the foundation of the field of study called <em>digital physics</em>. Zuse&#39;s first model is a 3D particle CA.</p>
<p><img src="img/zuse.jpg" alt="Zuse&#39;s vision of nature"></p>
<h3>Asynchronous CA</h3>
<p>Instead of updating all cells at once, update one cell at a time, according to some update policy. The same choices can be applied per-block in a block-rule CA.</p>
<ul>
<li>A fixed update policy, such as linear scan or pre-determined path, is orderly, but may introduce artifacts (related to the <em>double-buffering</em> pattern). </li>
<li>A <em>probabilistic asynchronous CA</em> chooses the next active cell according to a random selection (related to the Monte Carlo methods described below).</li>
<li>A multi-rate CA (self-clocked) updates each cell according to a clock period that varies from cell to cell. The clock period could also be affected by neighbors, to achieve <em>entrainment</em> effects.</li>
<li>A <em>mobile CA</em> chooses a related cell (such as one of the neighbors) of the current active cell as the next active cell. So in addition to choosing a new state for the cell, the transition rule must also choose how to move the active cell. This could also be partly probabilistic.</li>
</ul>
<p><a href="http://en.wikipedia.org/wiki/Langton%27s_ant">Langton&#39;s Ant</a> is a mobile CA in a 2D, two-state space, with very simple rules:</p>
<ul>
<li>At a white square, turn 90° right, flip the color of the square, move forward one unit</li>
<li>At a black square, turn 90° left, flip the color of the square, move forward one unit</li>
</ul>
<p><a href="https://github.com/grrrwaaa/gct753/blob/master/ca_2D_langtons_ant.lua">See the script</a> in the repo, and the <a href="http://www.youtube.com/watch?v=w6XQQhCgq5c">original video by Christopher Langton</a>, including examples of multiple ants (and music by the Vasulkas). Note that Langton&#39;s Ant, and other related Turmites, are closely related to the turtle graphics often used for L-systems.</p>
<h3>Continuous automata</h3>
<p><strong>Continuous states:</strong> In this case, the states are not discrete but belong to a continuum, such as the linear range 0..1. Instead of using a discrete transition rule or lookup table, continuous functions can be used (or combined with discrete rules such as comparisons). Continuous automata can show liquid and diffusive effects.</p>
<p><strong>Continuous neighborhood:</strong> Instead of accumulating whole neighbor cells, apply a <em>kernel</em> region, weighting cells according to the degree that they fall under a radius, or by distance.</p>
<p><a href="http://www.youtube.com/playlist?list=PL69EDA11384365494">SmoothLife</a> still uses a discrete grid, but both the kernel and transition functions are adjusted for smooth, continuous values; it removes the discrete bias and leads to fascinating results. <a href="http://www.youtube.com/watch?v=l7t8LtdBAV8">Another implementaton</a>. <a href="http://www.youtube.com/watch?v=zA857JdUn9o&amp;list=PL69EDA11384365494&amp;index=46">Taken to 3D</a>.</p>
<p>Can there be continuous space automata? If time were also continuous, they would simply be differential equations.</p>
<h4>Reaction Diffusion</h4>
<p>The reaction-diffusion model was proposed by Turing to describe embryo development and pattern-generation; it is still used today in CG. <a href="http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf">Turing, A. The Chemical Basic for Morphogenesis.</a>. RD systems and other differential equation systems can be approximated using continuous automata.</p>
<p><img src="img/xmorphia-parameter-map.jpg" alt="The Gray-Scott parameter map"></p>
<p>One approach to simulating RD using CA is the <em>Gray-Scott</em> model, as described in <a href="http://arxiv.org/pdf/patt-sol/9304003.pdf">Pearson, J. E. Complex Patterns in a Simple System</a>. There is <a href="http://mrob.com/pub/comp/xmorphia/">a wonderful archive of this model at this webpage</a>, including many great video examples of the <a href="http://www.youtube.com/watch?v=F5oKgVZ6bTk">u-skate world</a>, and even <a href="http://www.youtube.com/watch?v=B03lcPEmSOQ">u-skate in 3D</a>.</p>
<h3>Statistical and unbounded state models</h3>
<p>The <em>Ising model</em> of ferromagnetism in statistical mechanics can also be simulated in a <em>Monte Carlo</em> fashion. Each site (cell) has either positive or negative spin (we can encode that as 0 or 1 value). At each time step, consider a site at random, and evaluate the probability of changing state. If changing state moves the site toward energetic equilibrium with neighbors (determined according to the Hamiltonian of the site) , then the change is made. Otherwise, the change is made only with a small probability that is dependent on the energetic difference and overall temperature. Thus at high temperatures, the system remains noisy, while at low temperatures it gradually self-organizes into all sites with equal spin.</p>
<p>It is also related to the <em>contact process</em> model, which has been used to simulate the spread of infection: infected sites become healthy at a constant rate, while healthy sites become infected at a rate proportional to the number infected neighbor (see also the <em>HodgePodge</em> simulation). This can be extented to multiple states for a multitype contact process. The <em>voter model</em> similarly simulates the changing of opinion in social groups. </p>
<p>The cellular <em>Potts model</em> (also known as the <em>Glazier-Graner</em> model) generalizes these to allow more than two site states, and in some cases, an unbounded number of possible site states; however it still utilizes the notion of statistical movement toward neighbor equilibrium to drive change, though the definition of a local Hamiltonian. Variations have been used to model grain growth, foam, fluid flow, chemotaxis, biological cells, and even the developmental cycle of whole organisms. Note that in this field, the term <em>cell</em> is used not to refer to a site on the lattice, but to a whole group of connected sites that share the same state. So in modeling foam, a <em>cell</em> represents a single bubble, and is made of one or more <em>sites</em>. Most changes therefore happen at the boundaries between these cells.</p>
<p>Stan Marée used this model to simulate the whole life cycle of <a href="http://www-binf.bio.uu.nl/stan/Thesis/">Dictyostelium discoideum</a>.</p>
<h3>Multi-Scale Turing Patterns</h3>
<p><a href="http://www.jonathanmccabe.com/">Jonathan McCabe&#39;s cyclic multi-scale Turing patterns</a>, and a <a href="http://teemingvoid.blogspot.kr/2007/02/jonathan-mccabe-very-cellular-automata.html">commentary by Mitchell Whitelaw</a></p>
<p>Some of these systems share resemblance with analog video feedback (<a href="http://www.youtube.com/watch?v=hDYEVv9t32U">example</a>, <a href="http://www.youtube.com/watch?v=Uw5onuS2_mw">example</a>), which has been exploited by earlier media artists (notably the Steiner and Woody Vasulka).</p>
</div>
	
	<div class="footer">
	<img src="img/snake6_small.jpg" alt="Artificial Natures"><br/>
	Graham Wakefield, 2013</div>
	
</div>
</body>
</html>