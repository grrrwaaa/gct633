<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Programming</title>
    
<link href="css/site.css" media="screen" rel="stylesheet" type="text/css" />
<link href="css/highlight.default.css" media="screen" rel="stylesheet" type="text/css" />
<script src="js/jquery.js"></script>
<script src="js/highlight.pack.js"></script>
<script src="js/showdown.js" type="text/javascript"></script>
<script src="js/extensions/github.js" type="text/javascript"></script>
<script src="js/main.js" type="text/javascript"></script>
<link rel="icon" type="image/x-icon" href="favicon.ico" />
</head>
<body>
<div style="display: none" id="sourcetext">

![wondermark](http://wondermark.com/comics/190.gif)

# Programming

> [wikipedia:](http://en.wikipedia.org/wiki/Programming_language) A programming language is a formal language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs that control the behavior of a machine and/or to express algorithms precisely. The earliest programming languages preceded the invention of the computer, and were used to direct the behavior of machines such as Jacquard looms and [player pianos](http://en.wikipedia.org/wiki/Player_piano). Thousands of different programming languages have been created, mainly in the computer field, and still many are being created every year. Most programming languages describe computation in an imperative style, i.e., as a sequence of commands, although some languages, such as those that support functional programming or logic programming, use alternative forms of description.

When using a natural language to communicate with other people, human authors and speakers can be ambiguous and make small errors, and still expect their intent to be understood. However, figuratively speaking, computers "do exactly what they are told to do", and cannot "understand" what code the programmer intended to write. The combination of the language definition, a program, and the program's inputs must fully specify the external behavior that occurs when the program is executed. To make this easier, programming languages and implementations may provide many tools of specification and abstraction, and many libraries of re-usable routines and capabilities.

## Semiotics

Programming languages and implementations can be understood in terms of semiotics: the syntax, semantics and pragmatics.

### Syntax

**The relations among signs in formal structures.** Syntax specifies all possible (valid) combinations of the surface form. Usually textual, but can also be graphical. May be described using a grammar. 

A syntax checker verifies the input text matches the syntax rules, or may indicate an error otherwise. A syntactically correct piece of code is not necessarily semantically correct, just as a syntactically correct English sentence does not necessarily have a logical meaning ([E.g. Chomsky's "Colourless Green Ideas Sleep Furiously"](http://en.wikipedia.org/wiki/Colorless_green_ideas_sleep_furiously))

> The study of grammar, the rules of correct structure of language, can be traced back two and half thousand years in ancient India, where the belief had been held that the correct structure and intonation of words had power.

### Semantics

**The relation between signs and meaning (the things to which they refer).** Semantics maps from program language syntax to program behavior. Some semantic constraints can be analyzed from the source code, others may only be detectable once the program runs. Industry languages tend to include more features aimed to detect semantic errors at compile-time, such as strict type systems.

### Pragmatics

**The relation between signs and sign-using agents (e.g. programmers!).** In linguistics, pragmatics describes the relation between signs and the agent using them, and the way context relates to meaning. In computing, this may encompass the hardware (or virtual machine implementation) that a program runs on, the available libraries and resources, as well as real-world interactions and performance. 

The standard library and run-time system provided by a language implementation can be more important than the language itself.

## Programming languages

There are thousands of programming languages in use today. From a purely abstract, mathematical point of view, most of them have equivalent computing power (delimited by the [universal Turing machine](http://en.wikipedia.org/wiki/Turing-computable_function#Models_equivalent_to_the_Turing_machine_model)). Practically however the choice of language/implementation to use may depend on factors of performance, familiarity, the quality of documentation and supporting libraries, ease of distribution, and so on. 

### Try out different languages in the browser

- [Codepad.org](http://codepad.org/)
- [Repl.it](http://www.repl.it/languages)

### Hello, world

Since the K&R book ["The C Programming Language"](http://cm.bell-labs.com/cm/cs/cbook/), many language tutorials begin with the ["hello, world"](http://en.wikipedia.org/wiki/Hello_world_program) program: a program that simply prints "hello, world" and exits.

```cpp
// hello, world in C:
int main() {
	printf("hello, world\n");
	return 0;
}
```

```java
// hello, world in Java:
public class HelloWorld {
	public static void main(String [] args) {
		System.out.println("hello, world");
	}
}
```

```php
// hello, world in PHP:
&lt;?php echo("hello, world"); ?&gt;
```

```javascript
// hello, world in JavaScript:
console.log("hello, world");
```

```python
# hello, world in Python:
print("hello, world")
```

```lua
-- hello, world in lua:
print("hello, world")
```

See [more examples at codepad.org](http://codepad.org/hello-world)

## Compiled language example: C

The **C** programming language is one of the oldest still in wide use today, originally developed between 1969 and 1973 at AT&T Bell Labs. It became the 'de facto' language for system development in UNIX, and continues to be a primary language for software, operating systems, hardware devices, etc. today. It aims to provide a higher-level language that nevertheless does not obscure details of the underlying system. It is extremely well-defined and thus also serves as a consistent application binary interface (ABI) for operating between different programs and languages. For example, [LuaJIT can easily inter-operate with C via a foreign-function interface (FFI)](http://luajit.org/ext_ffi.html). 

Programs written in C stored in text files (with ".c" extension) and converted to binary applications (and libraries) using a **compiler** such as ```gcc``` or ```clang```; or simply invoked by the alias ```cc```. The following terminal command tells the compiler to compile the file ```hello.c``` and save the binary executable output (via the ```-o``` flag) to be called ```hello```:

	cc hello.c -o hello
	
Now we can run this file like so:

	./hello
	
On Windows [it looks slightly different](http://msdn.microsoft.com/en-us/library/ms235639.aspx):

	cl hello.c
	hello
	
### Linking with a library	

What if the standard C run-time library doesn't offer capabilities we need? Then we can search for a library that already exists and link to that (so long as the license fits our needs). For example, C doesn't know how to read and write sound files, but the [libsndfile](https://github.com/erikd/libsndfile) library is designed to do just that. So the first thing we need to do is download & install it. 

	...
	
Once installed, we need to tell the compiler where to find it. There are two parts to a library: the **binaries** which contain the actual machine code, and the **headers**, which are text files definining functions and types that tell you (and the compiler) how you can use the binaries. For example, library binaries might be installed into */usr/lib* or */usr/local/lib* on OSX/Linux, and headers into */usr/include* or */usr/local/include*. We can tell the compiler where to look using the **-I** and **-L** flags (**/I** and **/link /LIBPATH** on Windows):

	cc -I/usr/local/include hello.c -L/usr/local/lib -o hello
	
But that only tells the compiler where to look. To actually use the headers we need to **#include** them in the source:

	&#35;include &lt;sndfile.h&gt;


And we also must tell the compiler to link the binary in our command, using the **-l** flag (or just the library name on Windows):

	cc -I/usr/local/include hello.c -L/usr/local/lib -lsndfile -o hello

Sometimes the header file of a library is enough to understand how to use it, but usually we also want to refer to human-friendly [documentation and tutorial material](http://www.mega-nerd.com/libsndfile/api.html). 

This is only a *very very very basic* introduction to compiling C from the command line; reality can be *far far far more complicated*. Too complicated, really.

## Live Programming, Live Coding

[Zen and the art of Live Programming](http://www.infoq.com/presentations/Live-Programming)
[TOPLAP](http://toplap.org/)
[Strange Places (Andrew Sorensen)](http://www.youtube.com/watch?v=TxQJPNSzl9s)

-----

## Setting up a C development environment

** THIS SECTION IS INCOMPLETE **

Your operating system might not come with a compiler built-in, and it probably doesn't have all the libraries you need. Here's some quick notes on getting set up:

### Linux

Getting a compiler:

	sudo apt-get install gcc
	
For any other libraries, you can often get them with

	sudo apt-get install &lt;libraryname&gt;

In this case, *sudo* means execute with administrative privileges, *apt-get* is a program for installing software and libraries (a "package manager"), *install* is the action for apt-get, and *gcc* is the application we will install (it will also install all dependencies).

### OSX

Getting a compiler: For recent versions of OSX you must install command line tools manually. [You can do this from inside Xcode, or as a direct download from Apple](http://stackoverflow.com/questions/9329243/xcode-4-4-command-line-tools). Either way you will need to register with the Apple developer center. 

For any other libraries: There is no built-in "package manager" for OSX, but there are several that people have written. I currently recommend using one called "brew", which you can install by [following the instructions here](http://brew.sh). Once installed, run *brew doctor* to ensure your system is properly configured; do whatever it says until it is happy. Then, to install librares:

	brew install &lt;libraryname&gt;

### Windows

Install a recent Visual Studio (e.g. Visual Studio 2012); this includes a compiler and a command line, found in the Start menu under "Visual Studio command prompt".

Package managers for Windows are less usual; many libraries provide binaries or installers directly instead.

</div>
<div id="wrapper">
	<div class="header">
		<h1>GCT 633</h1>
		<a href="index.html">Overview</a><br/>
		<a href="time.html">Time</a><br/>
		<a href="programming.html">Programming</a><br/>
		<a href="audio.html">Audio</a><br/>
		<a href="lua.html">Lua Tutorial</a><br/>
		<a href="docs/index.html">&gt;&gt; Reference</a><br/>
		<a href="http://github.com/grrrwaaa/gct633">&gt;&gt; GitHub</a><br/>
	</div>
	<div class="section">
		<script type="text/javascript">
		//var converter = new Markdown.Converter();
		var converter = new Showdown.converter({ extensions: "g" });
		document.write(converter.makeHtml($('#sourcetext').text()));
		</script>
	</div>	
	<div class="footer">
		<img src="img/snake6_small.jpg" alt="Graham Wakefield"><br/>
		Graham Wakefield, 2013</div>
	</div>
</body>
</html>